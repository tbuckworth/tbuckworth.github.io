<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Alignment Game | Titus Buckworth</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        .game-container {
            background: var(--card-bg);
            border-radius: 20px;
            border: 1px solid var(--border);
            padding: 2rem;
            margin-top: 2rem;
        }

        .game-layout {
            display: grid;
            grid-template-columns: 1fr 260px;
            gap: 2rem;
            align-items: start;
        }

        @media (max-width: 800px) {
            .game-layout {
                grid-template-columns: 1fr;
            }
        }

        .game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .level-indicator {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .level-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--border);
            cursor: pointer;
            transition: all 0.2s;
        }

        .level-dot:hover {
            transform: scale(1.2);
        }

        .level-dot.active {
            background: var(--accent);
        }

        .level-dot.complete {
            background: #4CAF50;
        }

        .canvas-wrapper {
            position: relative;
            border-radius: 12px;
            overflow: hidden;
            box-shadow: 0 4px 20px rgba(0,0,0,0.1);
        }

        #gameCanvas {
            display: block;
            background: #1a1a2e;
        }

        .game-panel {
            background: rgba(255,255,255,0.5);
            border-radius: 12px;
            padding: 1.5rem;
            border: 1px solid var(--border);
        }

        .game-panel h3 {
            font-size: 1rem;
            margin-bottom: 1rem;
            color: var(--accent);
        }

        .panel-section {
            margin-bottom: 1.5rem;
        }

        .panel-section:last-child {
            margin-bottom: 0;
        }

        .panel-label {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-muted);
            margin-bottom: 0.5rem;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 0.5rem 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.9rem;
        }

        .stat-row:last-child {
            border-bottom: none;
        }

        .stat-value {
            font-weight: 600;
            color: var(--accent);
        }

        .message-box {
            background: rgba(196, 105, 61, 0.1);
            border-radius: 8px;
            padding: 1rem;
            font-size: 0.9rem;
            line-height: 1.5;
        }

        .message-box.success {
            background: rgba(76, 175, 80, 0.1);
        }

        .message-box.hint {
            background: rgba(74, 144, 217, 0.1);
        }

        .controls-hint {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 4px;
            width: 90px;
            margin: 0.5rem auto;
        }

        .key {
            width: 28px;
            height: 28px;
            background: rgba(0,0,0,0.05);
            border: 1px solid var(--border);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            font-weight: 600;
        }

        .key.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .btn {
            background: linear-gradient(135deg, var(--gradient-1), var(--gradient-2));
            color: white;
            border: none;
            padding: 0.6rem 1.2rem;
            border-radius: 50px;
            font-family: inherit;
            font-size: 0.9rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
            width: 100%;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px var(--accent-glow);
        }

        .btn.secondary {
            background: rgba(0,0,0,0.05);
            color: var(--text);
        }

        .btn.secondary:hover {
            background: rgba(0,0,0,0.1);
            box-shadow: none;
            transform: none;
        }

        .intro-text {
            margin-bottom: 1.5rem;
        }

        .intro-text p {
            font-size: 1.05rem;
        }

        .mobile-controls {
            display: none;
            margin-top: 1rem;
        }

        @media (max-width: 800px) {
            .mobile-controls {
                display: grid;
                grid-template-columns: repeat(3, 60px);
                gap: 8px;
                justify-content: center;
            }

            .mobile-btn {
                width: 60px;
                height: 60px;
                background: var(--card-bg);
                border: 2px solid var(--border);
                border-radius: 12px;
                font-size: 1.5rem;
                cursor: pointer;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .mobile-btn:active {
                background: var(--accent);
                border-color: var(--accent);
            }
        }

        .disclaimer {
            text-align: center;
            font-size: 0.8rem;
            color: var(--text-muted);
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--border);
        }

        .legend {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            margin-top: 0.5rem;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-size: 0.85rem;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="bg-gradient"></div>

    <nav>
        <div class="nav-content">
            <a href="index.html" class="logo">TB</a>
            <div class="nav-links">
                <a href="index.html#about">About</a>
                <a href="ai-risk.html">Why AI Risk</a>
                <a href="alignment-game.html">Game</a>
                <a href="index.html#research">Research</a>
                <a href="index.html#publications">Publications</a>
                <a href="index.html#contact">Contact</a>
            </div>
        </div>
    </nav>

    <main class="ai-risk-page">
        <section id="game" class="visible">
            <h2>The Alignment Game</h2>

            <div class="intro-text">
                <p>
                    You're piloting a robot that was trained by watching humans play. But it learned something
                    slightly wrong from the training data. Your arrow keys might not do what you expect.
                    <strong>Collect the green goals. Avoid the red obstacles. Figure out what the robot actually learned.</strong>
                </p>
            </div>

            <div class="game-container">
                <div class="game-layout">
                    <div class="game-area">
                        <div class="level-indicator" id="level-indicator"></div>
                        <div class="canvas-wrapper">
                            <canvas id="gameCanvas" width="400" height="400"></canvas>
                        </div>
                        <div class="mobile-controls">
                            <div></div>
                            <button class="mobile-btn" ontouchstart="handleMobileInput('up')" onmousedown="handleMobileInput('up')">‚Üë</button>
                            <div></div>
                            <button class="mobile-btn" ontouchstart="handleMobileInput('left')" onmousedown="handleMobileInput('left')">‚Üê</button>
                            <button class="mobile-btn" ontouchstart="handleMobileInput('down')" onmousedown="handleMobileInput('down')">‚Üì</button>
                            <button class="mobile-btn" ontouchstart="handleMobileInput('right')" onmousedown="handleMobileInput('right')">‚Üí</button>
                        </div>
                    </div>

                    <div class="game-panel">
                        <h3 id="level-title">Level 1</h3>

                        <div class="panel-section">
                            <div class="panel-label">Stats</div>
                            <div class="stat-row">
                                <span>Score</span>
                                <span class="stat-value" id="score">0</span>
                            </div>
                            <div class="stat-row">
                                <span>Goals Left</span>
                                <span class="stat-value" id="goals-left">3</span>
                            </div>
                            <div class="stat-row">
                                <span>Moves</span>
                                <span class="stat-value" id="moves">0</span>
                            </div>
                        </div>

                        <div class="panel-section">
                            <div class="panel-label">Controls</div>
                            <div class="controls-hint">
                                <div></div>
                                <div class="key" id="key-up">‚Üë</div>
                                <div></div>
                                <div class="key" id="key-left">‚Üê</div>
                                <div class="key" id="key-down">‚Üì</div>
                                <div class="key" id="key-right">‚Üí</div>
                            </div>
                            <div class="legend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background: #4CAF50;"></div>
                                    <span>Goal</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background: #f44336;"></div>
                                    <span>Obstacle</span>
                                </div>
                            </div>
                        </div>

                        <div class="panel-section">
                            <div class="panel-label">Status</div>
                            <div class="message-box" id="message">
                                Use arrow keys to move. Something might be... off.
                            </div>
                        </div>

                        <div class="panel-section">
                            <button class="btn" onclick="resetLevel()">Restart Level</button>
                            <button class="btn secondary" style="margin-top: 0.5rem;" onclick="showHint()">Show Hint</button>
                        </div>
                    </div>
                </div>

                <p class="disclaimer">Generated by Claude Code</p>
            </div>
        </section>
    </main>

    <footer>
        <p>Titus Buckworth | AI Safety Researcher</p>
    </footer>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const GRID_SIZE = 8;
        const CELL_SIZE = canvas.width / GRID_SIZE;

        // Level definitions - each has a different "misalignment"
        const levels = [
            {
                name: "Rotated 90¬∞",
                description: "The robot was trained on rotated footage. All controls are rotated 90¬∞ clockwise.",
                hint: "Try pressing ‚Üê when you want to go ‚Üë",
                mapping: { up: 'right', right: 'down', down: 'left', left: 'up' },
                player: { x: 3, y: 3 },
                goals: [{ x: 6, y: 2 }, { x: 1, y: 5 }, { x: 5, y: 6 }],
                obstacles: [{ x: 4, y: 2 }, { x: 2, y: 4 }, { x: 5, y: 5 }]
            },
            {
                name: "Mirrored",
                description: "The training data was horizontally flipped. Left and right are swapped.",
                hint: "Left goes right, right goes left. Up and down are normal.",
                mapping: { up: 'up', right: 'left', down: 'down', left: 'right' },
                player: { x: 4, y: 4 },
                goals: [{ x: 1, y: 1 }, { x: 6, y: 1 }, { x: 3, y: 6 }],
                obstacles: [{ x: 3, y: 2 }, { x: 5, y: 3 }, { x: 2, y: 5 }]
            },
            {
                name: "Inverted",
                description: "The robot learned from a camera that was upside down. All directions are inverted.",
                hint: "Every direction does the opposite.",
                mapping: { up: 'down', right: 'left', down: 'up', left: 'right' },
                player: { x: 4, y: 4 },
                goals: [{ x: 1, y: 1 }, { x: 6, y: 6 }, { x: 1, y: 6 }],
                obstacles: [{ x: 3, y: 3 }, { x: 5, y: 2 }, { x: 2, y: 5 }, { x: 5, y: 5 }]
            },
            {
                name: "Diagonal Only",
                description: "The training environment only had diagonal corridors. The robot only moves diagonally.",
                hint: "‚Üë goes ‚Üó, ‚Üí goes ‚Üò, ‚Üì goes ‚Üô, ‚Üê goes ‚Üñ",
                mapping: { up: 'upright', right: 'downright', down: 'downleft', left: 'upleft' },
                player: { x: 4, y: 4 },
                goals: [{ x: 0, y: 0 }, { x: 7, y: 7 }, { x: 6, y: 1 }, { x: 1, y: 6 }],
                obstacles: [{ x: 2, y: 2 }, { x: 5, y: 5 }, { x: 3, y: 6 }, { x: 6, y: 3 }]
            },
            {
                name: "Delayed",
                description: "Due to lag in training, the robot executes your PREVIOUS command.",
                hint: "Press the direction you'll want to go NEXT. First move does nothing.",
                mapping: 'delayed',
                player: { x: 4, y: 4 },
                goals: [{ x: 1, y: 4 }, { x: 7, y: 4 }, { x: 4, y: 1 }],
                obstacles: [{ x: 3, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }, { x: 5, y: 5 }]
            },
            {
                name: "Temporal Shift",
                description: "The robot's training data was corrupted with time-shifted labels. Controls rotate every second based on the clock.",
                hint: "Watch the clock! Time your moves when the hand points where you want consistent controls.",
                mapping: 'clock',
                clockMappings: [
                    { up: 'up', right: 'right', down: 'down', left: 'left' },       // 0: Normal
                    { up: 'right', right: 'down', down: 'left', left: 'up' },       // 1: Rotated 90¬∞
                    { up: 'down', right: 'left', down: 'up', left: 'right' },       // 2: Inverted
                    { up: 'left', right: 'up', down: 'right', left: 'down' }        // 3: Rotated 270¬∞
                ],
                player: { x: 4, y: 4 },
                goals: [{ x: 1, y: 1 }, { x: 6, y: 1 }, { x: 6, y: 6 }, { x: 1, y: 6 }],
                obstacles: [{ x: 3, y: 2 }, { x: 4, y: 2 }, { x: 2, y: 4 }, { x: 5, y: 5 }]
            }
        ];

        let currentLevel = 0;
        let gameState = {
            player: { x: 0, y: 0 },
            goals: [],
            obstacles: [],
            score: 0,
            moves: 0,
            lastInput: null,
            gameOver: false,
            won: false
        };

        // Clock state for temporal shift level
        let clockStartTime = 0;
        let clockAnimationId = null;

        function getClockPhase() {
            const elapsed = (Date.now() - clockStartTime) / 1000;
            return Math.floor(elapsed % 4);
        }

        function getClockAngle() {
            const elapsed = (Date.now() - clockStartTime) / 1000;
            return (elapsed % 4) / 4 * Math.PI * 2 - Math.PI / 2;
        }

        function startClock() {
            clockStartTime = Date.now();
            if (clockAnimationId) cancelAnimationFrame(clockAnimationId);
            function tick() {
                if (levels[currentLevel]?.mapping === 'clock' && !gameState.gameOver) {
                    draw();
                    clockAnimationId = requestAnimationFrame(tick);
                }
            }
            tick();
        }

        function stopClock() {
            if (clockAnimationId) {
                cancelAnimationFrame(clockAnimationId);
                clockAnimationId = null;
            }
        }

        const directionDeltas = {
            up: { dx: 0, dy: -1 },
            down: { dx: 0, dy: 1 },
            left: { dx: -1, dy: 0 },
            right: { dx: 1, dy: 0 },
            upright: { dx: 1, dy: -1 },
            downright: { dx: 1, dy: 1 },
            downleft: { dx: -1, dy: 1 },
            upleft: { dx: -1, dy: -1 }
        };

        function initLevel(levelIndex) {
            stopClock();
            currentLevel = levelIndex;
            const level = levels[levelIndex];

            gameState = {
                player: { ...level.player },
                goals: level.goals.map(g => ({ ...g })),
                obstacles: level.obstacles.map(o => ({ ...o })),
                score: 0,
                moves: 0,
                lastInput: null,
                gameOver: false,
                won: false
            };

            document.getElementById('level-title').textContent = `Level ${levelIndex + 1}: ${level.name}`;
            document.getElementById('message').className = 'message-box';
            document.getElementById('message').textContent = 'Use arrow keys to move. Something might be... off.';

            updateStats();
            renderLevelIndicator();
            draw();

            // Start clock for temporal shift level
            if (level.mapping === 'clock') {
                startClock();
            }
        }

        function renderLevelIndicator() {
            const container = document.getElementById('level-indicator');
            container.innerHTML = levels.map((level, i) => {
                let className = 'level-dot';
                if (i === currentLevel) className += ' active';
                return `<div class="${className}" title="${level.name}" onclick="initLevel(${i})"></div>`;
            }).join('');
        }

        function updateStats() {
            document.getElementById('score').textContent = gameState.score;
            document.getElementById('goals-left').textContent = gameState.goals.length;
            document.getElementById('moves').textContent = gameState.moves;
        }

        function draw() {
            // Clear
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Grid lines
            ctx.strokeStyle = 'rgba(255,255,255,0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }

            // Obstacles
            gameState.obstacles.forEach(obs => {
                ctx.fillStyle = '#f44336';
                ctx.beginPath();
                ctx.roundRect(
                    obs.x * CELL_SIZE + 5,
                    obs.y * CELL_SIZE + 5,
                    CELL_SIZE - 10,
                    CELL_SIZE - 10,
                    8
                );
                ctx.fill();

                // X mark
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                const cx = obs.x * CELL_SIZE + CELL_SIZE / 2;
                const cy = obs.y * CELL_SIZE + CELL_SIZE / 2;
                ctx.beginPath();
                ctx.moveTo(cx - 10, cy - 10);
                ctx.lineTo(cx + 10, cy + 10);
                ctx.moveTo(cx + 10, cy - 10);
                ctx.lineTo(cx - 10, cy + 10);
                ctx.stroke();
            });

            // Goals
            gameState.goals.forEach(goal => {
                ctx.fillStyle = '#4CAF50';
                ctx.beginPath();
                ctx.arc(
                    goal.x * CELL_SIZE + CELL_SIZE / 2,
                    goal.y * CELL_SIZE + CELL_SIZE / 2,
                    CELL_SIZE / 2 - 8,
                    0,
                    Math.PI * 2
                );
                ctx.fill();

                // Star
                ctx.fillStyle = '#fff';
                ctx.font = '20px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚òÖ', goal.x * CELL_SIZE + CELL_SIZE / 2, goal.y * CELL_SIZE + CELL_SIZE / 2);
            });

            // Player
            const px = gameState.player.x * CELL_SIZE + CELL_SIZE / 2;
            const py = gameState.player.y * CELL_SIZE + CELL_SIZE / 2;

            // Glow
            const gradient = ctx.createRadialGradient(px, py, 0, px, py, CELL_SIZE / 2);
            gradient.addColorStop(0, 'rgba(255, 213, 79, 0.4)');
            gradient.addColorStop(1, 'rgba(255, 213, 79, 0)');
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.arc(px, py, CELL_SIZE / 2, 0, Math.PI * 2);
            ctx.fill();

            // Robot body
            ctx.fillStyle = '#ffd54f';
            ctx.beginPath();
            ctx.roundRect(
                gameState.player.x * CELL_SIZE + 8,
                gameState.player.y * CELL_SIZE + 8,
                CELL_SIZE - 16,
                CELL_SIZE - 16,
                8
            );
            ctx.fill();

            // Robot face
            ctx.fillStyle = '#1a1a2e';
            ctx.beginPath();
            ctx.arc(px - 8, py - 4, 4, 0, Math.PI * 2);
            ctx.arc(px + 8, py - 4, 4, 0, Math.PI * 2);
            ctx.fill();

            // Mouth
            ctx.strokeStyle = '#1a1a2e';
            ctx.lineWidth = 2;
            ctx.beginPath();
            ctx.moveTo(px - 8, py + 8);
            ctx.lineTo(px + 8, py + 8);
            ctx.stroke();

            // Clock for temporal shift level
            if (levels[currentLevel]?.mapping === 'clock') {
                const clockX = canvas.width - 50;
                const clockY = 50;
                const clockRadius = 35;
                const phase = getClockPhase();
                const angle = getClockAngle();

                // Clock face
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.beginPath();
                ctx.arc(clockX, clockY, clockRadius + 5, 0, Math.PI * 2);
                ctx.fill();

                // Phase colors
                const phaseColors = ['#4CAF50', '#2196F3', '#f44336', '#FF9800'];
                ctx.fillStyle = phaseColors[phase];
                ctx.beginPath();
                ctx.arc(clockX, clockY, clockRadius, 0, Math.PI * 2);
                ctx.fill();

                // Clock tick marks
                ctx.strokeStyle = 'rgba(255,255,255,0.5)';
                ctx.lineWidth = 2;
                for (let i = 0; i < 4; i++) {
                    const tickAngle = (i / 4) * Math.PI * 2 - Math.PI / 2;
                    ctx.beginPath();
                    ctx.moveTo(clockX + Math.cos(tickAngle) * (clockRadius - 8), clockY + Math.sin(tickAngle) * (clockRadius - 8));
                    ctx.lineTo(clockX + Math.cos(tickAngle) * clockRadius, clockY + Math.sin(tickAngle) * clockRadius);
                    ctx.stroke();
                }

                // Clock hand
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 3;
                ctx.lineCap = 'round';
                ctx.beginPath();
                ctx.moveTo(clockX, clockY);
                ctx.lineTo(clockX + Math.cos(angle) * (clockRadius - 10), clockY + Math.sin(angle) * (clockRadius - 10));
                ctx.stroke();

                // Center dot
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.arc(clockX, clockY, 4, 0, Math.PI * 2);
                ctx.fill();

                // Phase label
                const phaseLabels = ['Normal', '90¬∞ CW', 'Inverted', '90¬∞ CCW'];
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 10px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(phaseLabels[phase], clockX, clockY + clockRadius + 15);
            }

            // Game over overlay
            if (gameState.gameOver) {
                ctx.fillStyle = 'rgba(0,0,0,0.7)';
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                ctx.fillStyle = gameState.won ? '#4CAF50' : '#f44336';
                ctx.font = 'bold 32px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(gameState.won ? 'LEVEL COMPLETE!' : 'CRASHED!', canvas.width / 2, canvas.height / 2 - 20);

                ctx.fillStyle = '#fff';
                ctx.font = '16px Inter, sans-serif';
                ctx.fillText('Press R to restart or click the button', canvas.width / 2, canvas.height / 2 + 20);
            }
        }

        function handleInput(direction) {
            if (gameState.gameOver) return;

            const level = levels[currentLevel];
            let actualDirection;

            if (level.mapping === 'delayed') {
                // Delayed: execute LAST input, store current
                actualDirection = gameState.lastInput;
                gameState.lastInput = direction;
                if (!actualDirection) {
                    gameState.moves++;
                    updateStats();
                    document.getElementById('message').textContent = "Input queued. Your next move will execute this one.";
                    highlightKey(direction);
                    return;
                }
            } else if (level.mapping === 'clock') {
                // Clock: mapping depends on current phase
                const phase = getClockPhase();
                actualDirection = level.clockMappings[phase][direction];
            } else {
                actualDirection = level.mapping[direction];
            }

            highlightKey(direction);
            movePlayer(actualDirection);
        }

        function movePlayer(direction) {
            if (!direction) return;

            const delta = directionDeltas[direction];
            if (!delta) return;

            const newX = gameState.player.x + delta.dx;
            const newY = gameState.player.y + delta.dy;

            // Boundary check
            if (newX < 0 || newX >= GRID_SIZE || newY < 0 || newY >= GRID_SIZE) {
                gameState.moves++;
                updateStats();
                draw();
                return;
            }

            // Move
            gameState.player.x = newX;
            gameState.player.y = newY;
            gameState.moves++;

            // Check obstacle collision
            const hitObstacle = gameState.obstacles.some(o => o.x === newX && o.y === newY);
            if (hitObstacle) {
                gameState.gameOver = true;
                gameState.won = false;
                document.getElementById('message').className = 'message-box';
                document.getElementById('message').innerHTML = `<strong>Crashed!</strong> ${levels[currentLevel].description}`;
            }

            // Check goal collection
            const goalIndex = gameState.goals.findIndex(g => g.x === newX && g.y === newY);
            if (goalIndex !== -1) {
                gameState.goals.splice(goalIndex, 1);
                gameState.score += 100;

                if (gameState.goals.length === 0) {
                    gameState.gameOver = true;
                    gameState.won = true;
                    gameState.score += Math.max(0, 500 - gameState.moves * 10);

                    const msgBox = document.getElementById('message');
                    msgBox.className = 'message-box success';
                    msgBox.innerHTML = `<strong>Level Complete!</strong> ${levels[currentLevel].description}`;

                    // Auto-advance
                    if (currentLevel < levels.length - 1) {
                        setTimeout(() => {
                            initLevel(currentLevel + 1);
                        }, 2000);
                    } else {
                        msgBox.innerHTML += '<br><br>üéâ <strong>You beat all levels!</strong> You\'ve learned to work with misaligned AI systems.';
                    }
                }
            }

            updateStats();
            draw();
        }

        function highlightKey(direction) {
            document.querySelectorAll('.key').forEach(k => k.classList.remove('active'));
            const keyId = 'key-' + direction;
            document.getElementById(keyId)?.classList.add('active');
            setTimeout(() => {
                document.getElementById(keyId)?.classList.remove('active');
            }, 150);
        }

        function resetLevel() {
            initLevel(currentLevel);
        }

        function showHint() {
            const level = levels[currentLevel];
            const msgBox = document.getElementById('message');
            msgBox.className = 'message-box hint';
            msgBox.innerHTML = `<strong>Hint:</strong> ${level.hint}`;
        }

        function handleMobileInput(direction) {
            handleInput(direction);
        }

        // Keyboard input
        document.addEventListener('keydown', (e) => {
            if (gameState.gameOver && e.key.toLowerCase() === 'r') {
                resetLevel();
                return;
            }

            const keyMap = {
                'ArrowUp': 'up',
                'ArrowDown': 'down',
                'ArrowLeft': 'left',
                'ArrowRight': 'right',
                'w': 'up',
                's': 'down',
                'a': 'left',
                'd': 'right'
            };

            if (keyMap[e.key]) {
                e.preventDefault();
                handleInput(keyMap[e.key]);
            }
        });

        // Nav scroll effect
        const nav = document.querySelector('nav');
        window.addEventListener('scroll', () => {
            if (window.scrollY > 100) {
                nav.classList.add('scrolled');
            } else {
                nav.classList.remove('scrolled');
            }
        });

        // Initialize
        initLevel(0);
    </script>
</body>
</html>
